'''
@author: mtancoigne
@version:0.1
@license: MIT

Tested with python 2.7

Converts challenge files to js files containg a constant to use in challenges.
'''

import os, time, re

# Working path
path = './challenges/'

# Header for the generated file
fileHeader = '/*\n  THIS FILE HAS BEEN GENERATED, DO NOT EDIT. \n  Generated by generate.py on ' + (time.strftime("%d/%m/%Y, %H:%M:%S")) + '\n*/\n\n'

# Javascript strings starting/finishing the file, depending on its type.
# The final file will have this format:
# header, language-specific-header, content, language-specific-footer, footer
jsStrings = {
    'languages':{
        # PHP
        'php': {
            'test': {
                'start': '"\\n\\n?>",\n',
                'end': ''
            },
            'challenge': {'start': '', 'end': ''}
        },
        # Python
        'py': {
            'test': {'start': '', 'end': ''},
            'challenge': {'start': '', 'end': ''}
        },
        # Ruby
        'rb': {
            'test': {'start': '', 'end': ''},
            'challenge': {'start': '', 'end': ''}
        }
    },
    'test': {
        'start': fileHeader + 'const CHALLENGE_ASSERTIONS=[\n',
        'end': '].join("\\n");\n',
    },
    'challenge': {
        'start': fileHeader + 'const CHALLENGE=[\n',
        'end': '].join("\\n");\n',
    }
}

# Get the folder names as file types
fileTypes = os.listdir(path)

# Table of strings to escape
escape_table = {
    '\\': '\\\\',  # the \ character
    '"': '\\"',    # the " character
    # new lines
    "\n": '',
    "\r": '',
}

# Function that replaces chars by their escaped correspondance.
def escape_lang(text):
    return ''.join(escape_table.get(c, c) for c in text)

# Nice greater, the kind of thing you decide to do at 2am, running out of coffee
print'\n'\
' (\n' \
' )\ )               (         (         (\n' \
'(()/( (     (   (   )\        )\ )  (   )\     )    )\n' \
' /(_)))(   ))\ ))\(((_)  (   (()/( ))\(((_) ( /(   (    `  )\n' \
'(_))_(()\ /((_)((_)\___  )\   ((_))((_)\___ )(_))  )\  \'/(/(\n' \
'| |_  ((_|_))(_))((/ __|((_)  _| (_))((/ __((_)_ _((_))((_)_\\\n' \
'| __|| \'_/ -_) -_)| (__/ _ \/ _` / -_)| (__/ _` | \'  \() \'_ \)\n' \
'|_|  |_| \___\___| \___\___/\__,_\___| \___\__,_|_|_|_|| .__/\n' \
'   Backend challenge and assertions converter          |_|\n'

# Actual script
for ext in fileTypes:
    # We loop through the folder, searching for sources
    for root, dirs, files in os.walk(path+ext):
        # Find files with the good extension
        for fileName in files:
            if fileName.endswith('.' + ext):
                # Resetting vars
                process = False
                scriptHead = ''
                scriptEnd = ''
                langHead = ''
                langEnd = ''

                # Getting file-specific head/end
                if fileName.endswith('challenge.'+ext):
                    scriptHead = jsStrings['challenge']['start']
                    langHead = jsStrings['languages'][ext]['challenge']['start']
                    langEnd = jsStrings['languages'][ext]['challenge']['end']
                    scriptEnd = jsStrings['challenge']['end']
                    process = True
                elif fileName.endswith('test.'+ext):
                    scriptHead = jsStrings['test']['start']
                    langHead = jsStrings['languages'][ext]['test']['start']
                    langEnd = jsStrings['languages'][ext]['test']['end']
                    scriptEnd = jsStrings['test']['end']
                    process = True

                # Process the file
                if process:
                    print 'Processing file ' + fileName

                    f = open(root + '/' + fileName, "r")
                    lines = f.readlines()
                    f.close()

                    nf = open(root + '/' + os.path.splitext(fileName)[0] + '.js', 'w')
                    nf.writelines(scriptHead)
                    nf.writelines(langHead)
                    for line in lines:
                        nf.writelines(''.join(['"', escape_lang(line), '",\n']))
                    nf.writelines(langEnd)
                    nf.writelines(scriptEnd)
                    nf.close()

print '\nDone.'
